# 1.继承Thread 类实现多线程

## 1.1 多线程实现同步下载图片

- 使用到 Apache.commons.io jar包

```java
package demo01;


import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;

//实现多线程同步下载图片
public class TestThread01 extends Thread{
    private String url;
    private String name;
    public TestThread01(String url,String name){
        this.url = url;
        this.name = name;
    }

    //线程执行体

    @Override
    public void run() {
        WebDownloader downloader = new WebDownloader();
        downloader.downloader(url,name);
        System.out.println("下载的文件 文件名为"+ name);
    }

    public static void main(String[] args) {
        TestThread01 t1 = new TestThread01("https://tse2-mm.cn.bing.net/th/id/OIP.WItaXdICxOycfyWN9d8veQHaHa?w=182&h=182&c=7&o=5&dpr=1.75&pid=1.7","1.jpg");
        TestThread01 t2 = new TestThread01("https://tse4-mm.cn.bing.net/th/id/OIP.ZZAqlHy-0MZIt-Jet0BpMAHaJ4?w=182&h=243&c=7&o=5&dpr=1.75&pid=1.7","2.jpg");

        t1.start();
        t2.start();
    }
}


//下载器
class WebDownloader{
    //下载方法
    public void downloader(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常，downloader方法出现问题");
        }
    }

}
```





# 2.实现Runnable接口

- `Thread`类中也实现了`Runnable`接口
- 避免了单继承的局限性，可以让多个线程 同时操作同一个对象（同一个对象的成员变量 共享）
- 多个线程同时操作同一个对象 会产生并发问题（数据紊乱）

```java
package demo01;
//模拟抢票
public class TestThread3 implements Runnable{

    private int tickets = 10;
    public void run(){
        while(tickets>0){
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"抢到了第"+tickets--+"张票");
        }
    }

    public static void main(String[] args) {
        //模拟抢票
        TestThread3 r = new TestThread3();

        //创建3个线程对象，同时操作一个对象
        new Thread(r, "小明").start();
        new Thread(r,"红花").start();
        new Thread(r,"老黄").start();
    }
}

```



- 龟兔赛跑问题（兔子睡觉，乌龟赢）--->就是sleep()的使用。。。

```java
package demo01;

public class Race implements Runnable{
    private static String winner = null;

    public void run() {

        for (int i = 0; i <= 20; i++) {
            //让兔子睡觉
            if(Thread.currentThread().getName().equals("兔子")&&i%5==0){
                try{
                    System.out.println("兔子睡觉");
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName()+"----->跑了"+i+"步");
            isWinner(i);
        }
    }

    //判断胜利者
    Boolean isWinner(int step){
        if(winner!=null){
            return true;
        }
        if(step==20){
            winner = Thread.currentThread().getName();
            System.out.println("当当当当 winner is "+winner);
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        Race r = new Race();

        new Thread(r,"兔子").start();
        new Thread(r,"乌龟").start();
    }
}

```



# 3.Callable接口的实现（了解）

1. 实现Callable 接口，需要返回值类型(返回值类型为call方法的返回值)
2. 重写call方法，需要抛出异常
3. 创建目标对象（不一定要用线程池来使用，也可以像实现Runnable接口一样来使用）
4. 创建执行服务：`ExecutorService ser = Executors.newFixedThreadPool(1);` (好像是个线程池)
5. 提交执行：`Future<Boolean> result1 = ser.submit(t1);`
6. 获取结果: `boolean r1 = result1.get();` :获取结果会阻塞进程，直到进程执行完毕获取到结果
7. 关闭服务： `ser.shutdownNow();`

